# Design


To breakdown the design of this project I will be using a tree diagram. The children are the requirements to make the parent like so:


```
Project
├── requirement 1
│   ├── nested requirement 1
│   └── nested requirement 2
└── requirement 2
```

That can be found in [This file](RequirementTree.md)

---


Due to it being online I also need to design a database which I will be using https://app.quickdatabasediagrams.com to do.



## Problems

### Networking

As the game is online multiplayer and online there needs to be some way of connecting to other players. As running my own servers would be expensive and also have risks because I'm opening up my network to the world, I will likely rent servers or use free ones. A common option is AWS but I have no idea how to use that so I will likely use render, which is a website another student in my class used to make a chat website. The server doesn't need to go under much stress because players aren't constantly moving, however, if tile updates are sent by the player and the server just accepts it then this is an opening for hacks and creates an unfair advantage in the game. We also have to consider the risk of malicous attacks to the server which seek to shut it down. This means we have to rate limit users from sending data and also the size of packets players send to the server have to be as small as they can get.


## Algorithms

### Chunking

With a tile based game that will have very large map sizes, the storing and rendering of tiles must be very optimised so the game runs as smooth as possible. The first prototype for this is to use chunking. The first time I wrote a chunking algorithm I stored the x and y position of the chunk and the tile.

```rs
struct Chunk {
    x: isize,
    y: isize,
    tiles: Vec<Tile>,
}
struct Tile {
   x: f32,
   y: f32,
}
```

Which was extremely inefficient because all chunks held the same number of tiles so the `tiles: Vec<Tile>` could be replaced with a static array and then the index of the tile in that array could be used to get the coordinates instead of unnecessarily taking up 64 bits per tile.

This was later refined to be:

```rs 
const CHUNK_SIZE: usize = 16; // Isn't necessary to be 16 but it is a common size for chunks in games

struct Chunk {
    x: isize,
    y: isize,
    tiles: [Tile; CHUNK_SIZE*CHUNK_SIZE],
}

struct Tile();
```

This is much better and to get the position of the tiles you just enumerate through the list to get the index and the tile and get the coordinates through `(i % CHUNK_SIZE, i / CHUNK_SIZE)`. As both `i` and `CHUNK_SIZE` are of the type `usize` no type conversion has to be done and the values are rounded appropriately.
This can be taken a step further as the chunks don't need to store their position. If we have a terrain struct that contains an array, it can act like the tiles array in the chunks. All we need is the dimensions of the map so that the x and y positions can be extracted properly and then fill the array with chunks. This results in the following:

```rs
const CHUNK_SIZE: usize = 16;

struct Tile();

struct Chunk {
    tiles: [Tile; CHUNK_SIZE*CHUNK_SIZE], // Square area
}

struct Terrain {
    position: Vec2,
    width: usize,
    height: usize,
    chunks: Vec<Chunk>,
}
```

The macroquad library includes a 2D vector data type which stores an `x: f32` and a `y: f32`. We use this datatype to store a root position of `Terrain` because otherwise the terrain would always be based off (0,0) and would only expand in the positive directions. An option could be to center the terrain but if we want other tiles to overlap and they are not properply sized then they won't be in the correct position with the tilemap`


But what information does the tile need to store? Having a tilemap of nothing would be quite pointless so the tile struct needs to store something to signify what it represents. At first I stored the value generated by the perlin noise function but that is an `f32` which is 32 bits to store a value that hardly ever changes so clearly an enum value would be better.

What tiles does the player need? Firstly, water is an incredibly important resource and forcing players to manage that could make the game quite interesting. It could also effect ground stability. A way of implementing this could be through perlin noise to determine the water density of the land.

